package main

import (
	"fmt"
	"math"
	"os"
	"time"
)

var plotcode int
var PI float64 = 3.14159265
var fid *os.File

var receiver Receiver = Receiver{point: []float64{-5, -3.08, 0}, radius: 0.2241}

var transmitter Transmitter = Transmitter{point: []float64{-2.0174, -2.58, 0}}

func getPoints(obj Object) {

	var sym = [][]float64{{1.0, -1.0, -1.0, 1.0}, {1.0, 1.0, -1.0, -1.0}}
	var sym2 = []float64{-1.0, 1.0}
	var dim = []float64{obj.length, obj.breadth, obj.height}
	for ii := 0; ii < 3; ii++ {
		var i = []int{ii % 3, (ii + 1) % 3, (ii + 2) % 3}
		for k := 0; k < 2; k++ {
			fmt.Fprint(fid, "planes")
			for j := 0; j < 4; j++ {
				fmt.Fprint(fid, " ", i[0], " ", obj.position[i[0]]+sym2[k]*dim[i[0]]/2)
				fmt.Fprint(fid, " ", i[1], " ", obj.position[i[1]]+sym[0][j]*dim[i[1]]/2)
				fmt.Fprint(fid, " ", i[2], " ", obj.position[i[2]]+sym[1][j]*dim[i[2]]/2)

			}
			fmt.Fprint(fid, "\n")
		}
	}
}

func raytrace(ray Ray, fieldStrength float64, pathLength float64, obstacles []Object, presentIndex int) int {
	var index, iii int
	t := 0.0

	//find the next obstacle in the path of the ray:
	indices := nextObject(-1, ray, obstacles)
	t = indices[0]
	iii = int(indices[1])
	index = int(indices[2])

	if t == 0 {
		return 1 //<----------------------------------!!!!TO DO!!!!---return point where ray dies------------------------------------------------
	}

	//check if it enters receiver region:
	receiverCheck := doesItPass(ray, receiver)
	didItReach := 0
	if receiverCheck[1] == 1 && receiverCheck[0] < t {
		t = receiverCheck[0]
		didItReach = 1
	}

	//find the point of intersection and set it for next rays:
	p := sum2(ray.point, dot(ray.direction, t))
	pathLength = pathLength + t*math.Sqrt(sum(dot2(ray.direction, ray.direction)))
	//var bufferRay Ray
	reflectedRay := Ray{point: p}
	transmittedRay := Ray{point: p}
	small_t := 0.01
	pp := sum2(p, dot(ray.direction, small_t))
	nextIndex := 0
	for lo := 0; lo < len(obstacles); lo++ {
		if isItInside(pp, obstacles[lo]) == 1 && lo != 0 {
			nextIndex = lo
		}
	}
	// ppp := sum2(p, dot(ray.direction, -small_t))
	// prevIndex := 0
	// for lo := 0; lo < len(obstacles); lo++ {
	// 	if isItInside(pp, obstacles[lo]) == 1 && lo != 0 {
	// 		prevIndex = lo
	// 	}
	// }

	//did it reach?
	if didItReach == 1 {
		//fmt.Print("reached!")
		timeOfReach := pathLength / 3e8
		//fmt.Print(pathLength, "\n")
		fmt.Fprint(fid, "Time ", timeOfReach, " ", fieldStrength, "\n")
		fmt.Fprint(fid, ray.point[0], " ", ray.point[1], " ", ray.point[2], " ", plotcode, "\n")
		fmt.Fprint(fid, p[0], " ", p[1], " ", p[2], " ", plotcode, "\n")
		plotcode++
		return 2
	}

	//field attenuation with distance:
	fieldStrength *= math.Exp(-1 * pathLength * 0.05)

	//if field falls below threshold (set as 0.1) then stop
	if fieldStrength < 0.01 {
		return 1
	}
	//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^!!!!TO DO!!!!---find exact point where the ray dies----------------------------------------

	//set the direction ratios of the reflected ray here:
	acc1 := sum(dot2(ray.direction, ray.direction))
	acc2 := -1.0 * (sum(dot2(ray.direction, getEquations(iii, obstacles[index]))))
	acc3 := sum(dot2(getEquations(iii, obstacles[index]), getEquations(iii, obstacles[index]))) - math.Pow(getEquations(iii, obstacles[index])[3], 2)
	t = acc2 / acc1
	normal_check1 := sum2(p, dot(ray.direction, small_t))
	normal_check2 := sum2(p, dot(getEquations(iii, obstacles[index]), small_t))
	f_normal := -1.0 * isSameSide(normal_check1, normal_check2, getEquations(iii, obstacles[index]))
	i_dot_n := 2.0 * acc2 // * f_normal;
	ans := sum2(dot(getEquations(iii, obstacles[index]), i_dot_n), ray.direction)
	reflectedRay.direction = ans

	//set the direction ratios of the transmitted ray here:
	cosTheta1 := -acc2 / math.Sqrt(acc1*acc3)
	sinTheta1 := math.Sin(math.Acos(cosTheta1))
	n := obstacles[presentIndex].r_index / obstacles[nextIndex].r_index
	sinTheta2 := n * sinTheta1
	//cosTheta2 := math.Cos(math.Asin(sinTheta2))
	t_c := -1.0 * math.Sqrt(1-math.Pow(sinTheta2, 2)) / math.Sqrt(acc3)
	lollipop := f_normal * cosTheta1 / math.Sqrt(acc3)
	t_par := dot(sum2(dot(ray.direction, 1/math.Sqrt(acc1)), dot(getEquations(iii, obstacles[index]), lollipop)), 2)
	t_per := dot(getEquations(iii, obstacles[index]), f_normal*t_c)
	t_total := sum2(t_par, t_per)
	transmittedRay.direction = t_total

	//trace the reflected and refracted rays next:
	ref_return := 1
	if index == 0 || presentIndex == 0 {
		ref_return = raytrace(reflectedRay, obstacles[presentIndex].r_coeff*fieldStrength, pathLength, obstacles, presentIndex)
	}
	trans_return := raytrace(transmittedRay, obstacles[index].t_coeff*fieldStrength, pathLength, obstacles, nextIndex)
	if ref_return*trans_return >= 2 {
		fmt.Fprint(fid, ray.point[0], " ", ray.point[1], " ", ray.point[2], " ", plotcode, "\n")
		fmt.Fprint(fid, p[0], " ", p[1], " ", p[2], " ", plotcode, "\n")
		plotcode++
	}
	return ref_return * trans_return
}

func main() {

	start := time.Now()

	fid, _ = os.Create("outgo.dat")

	fmt.Fprint(fid, "Receiver ", receiver.point[0], " ", receiver.point[1], " ", receiver.point[2], receiver.radius, "\n")
	fmt.Fprint(fid, "Transmitter ", transmitter.point[0], " ", transmitter.point[1], " ", transmitter.point[2], "\n")

	Room := Object{length: 13, breadth: 8.6, height: 3, r_coeff: 0.4, t_coeff: 0, r_index: 1, position: []float64{0, 0, 0}}
	getPoints(Room)

	Box := Object{length: 0.03, breadth: 2.5, height: 3, r_coeff: 0.4, t_coeff: 0, r_index: 2, position: []float64{-3.6586, -2.163, 0}}
	getPoints(Box)

	Box1 := Object{length: 0.91, breadth: 0.645, height: 3, r_coeff: 0.4, t_coeff: 0, r_index: 2, position: []float64{6.045, 3.9775, 0}}
	getPoints(Box1)

	Box2 := Object{length: 0.91, breadth: 0.645, height: 3, r_coeff: 0.4, t_coeff: 0, r_index: 2, position: []float64{-6.045, 3.9775, 0}}
	getPoints(Box2)

	Box3 := Object{length: 0.91, breadth: 0.645, height: 3, r_coeff: 0.4, t_coeff: 0, r_index: 2, position: []float64{6.045, -3.9775, 0}}
	getPoints(Box3)

	Box4 := Object{length: 0.91, breadth: 0.645, height: 3, r_coeff: 0.4, t_coeff: 0, r_index: 2, position: []float64{-6.045, -3.9775, 0}}
	getPoints(Box4)

	var obstacles []Object = []Object{Room, Box, Box1, Box2, Box3, Box4}

	//somehow start many rays from transmitter
	fR := 0.6
	fA := 0.02
	fB := 0.02
	count_rays := 0
	for fi := -fB * float64(int(fR/fB)); fi <= fR; fi = fi + fB {
		fr := math.Sqrt(math.Pow(fR, 2) - math.Pow(fi, 2))
		for fa := 0.0; fa <= 2*PI; fa = fa + fA/fr {
			rayX := Ray{point: transmitter.point, direction: []float64{fr * math.Cos(fa), fr * math.Sin(fa), fi}}
			raytrace(rayX, 1, 0, obstacles, 0)
			count_rays++
		}
	}

	fid.Close()
	elapsed := time.Since(start)
	fmt.Println("Processed ", count_rays, " rays in ", elapsed)
}
